package org.clyze.persistent.model.jvm;

import org.clyze.persistent.model.Position;
import org.clyze.persistent.model.Symbol;

import java.util.Map;
import java.util.Objects;

/**
 * This class represents a string constant such as a pair of a static final String
 * field and the string literal initializing it.
 *
 * Why do we need this?
 * Javac chooses to inline some cases of static final fields. Such fields do not
 * appear in the bytecode and therefore are not analyzed. What this class does
 * is to provide a "possible value" for such fields.
 */
public class JvmStringConstant extends Symbol {

    /** The id of the static final field that this string literal initializes. */
    private String fieldId;

    /** The string literal value.
     *
     *  This value may differ from the corresponding source code, since it is
     *  intentionally retrieved after the compiler has applied any possible
     *  concatenations; e.g. for the string literal in the rhs of:
     *      static final String str = "abc" + "def";
     *  javac will give us "abcdef", which we store in "value".
     *
     *  Note that the reported position corresponds to the source code and not
     *  the concatenated string generated by the compiler.
     */
    private String value;

    /** No-arg constructor, use setters or fromMap() to populate the object. */
    public JvmStringConstant() {}

    /**
     * Single-arg constructor, use setters or fromMap() to populate the object.
     * Used during deserialization.
     * @param id      a unique deserialization id
     */
    public JvmStringConstant(String id) {
        this.id = id;
    }

    /**
     * Create a string constant object.
     * @param position         the source position
     * @param sourceFileName   the source file name
     * @param source          if false, the symbol is compiler-generated or external/binary
     * @param fieldId          the id of the field initialized by this constant
     * @param value            the constant value
     */
    public JvmStringConstant(Position position,
                             String sourceFileName,
                             boolean source,
                             String fieldId,
                             String value) {
        super(position, sourceFileName, source);
        this.fieldId = fieldId;
        this.value = value;
    }

    @Override
    protected void saveTo(Map<String, Object> map) {
        super.saveTo(map);
        map.put("fieldId", getFieldId());
        map.put("value", getValue());
    }

    /**
     * Get the id of the field initialized by this string.
     * @return the field id
     */
    public String getFieldId() {
        return fieldId;
    }

    /**
     * Set the field initialized by this string.
     * @param fieldId   the field id
     */
    public void setFieldId(String fieldId) {
        this.fieldId = fieldId;
    }

    /**
     * Get the string initializer value.
     * @return   the constant string
     */
    public String getValue() {
        return value;
    }

    /**
     * Set the string initializer value.
     * @param value   the constant string
     */
    public void setValue(String value) {
        this.value = value;
    }

    @Override
    public boolean equals(Object object) {
        if (this == object) return true;
        if (object == null || getClass() != object.getClass()) return false;
        if (!super.equals(object)) return false;
        JvmStringConstant that = (JvmStringConstant) object;
        return Objects.equals(fieldId, that.fieldId) &&
               Objects.equals(value, that.value);
    }

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), fieldId, value);
    }

    @Override
    public void fromMap(Map<String, Object> map){
        super.fromMap(map);
        setFieldId((String) map.get("fieldId"));
        setValue((String) map.get("value"));
    }
}
