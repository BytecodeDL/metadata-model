package org.clyze.persistent.model.jvm;

import org.clyze.persistent.model.Position;
import org.clyze.persistent.model.Symbol;

import java.util.Map;
import java.util.Objects;

/**
 * This class represents a string constant such as a pair of a static final String
 * field and the string literal initializing it.
 *
 * Why do we need this?
 * Javac chooses to inline some cases of static final fields. Such fields do not
 * appear in the bytecode and therefore are not analyzed. What this class does
 * is to provide a "possible value" for such fields.
 */
public class JvmStringConstant extends Symbol {

    /** The id of the static final field that this string literal initializes. */
    private String fieldId;

    /** The string literal value.
     *
     *  This value may differ from the corresponding source code, since it is
     *  intentionally retrieved after the compiler has applied any possible
     *  concatenations; e.g. for the string literal in the rhs of:
     *      static final String str = "abc" + "def";
     *  javac will give us "abcdef", which we store in "value".
     *
     *  Note that the reported position corresponds to the source code and not
     *  the concatenated string generated by the compiler.
     */
    private String value;

    public JvmStringConstant() {}

    public JvmStringConstant(String id) {
        this.id = id;
    }
    
    public JvmStringConstant(Position position,
                             String sourceFileName,
                             String fieldId,
                             String value) {
        super(position, sourceFileName);
        this.fieldId = fieldId;
        this.value = value;
    }

    protected void saveTo(Map<String, Object> map) {
        super.saveTo(map);
        map.put("fieldId", this.fieldId);
        map.put("value", this.value);
    }

    public String getFieldId() {
        return fieldId;
    }

    public void setFieldId(String fieldId) {
        this.fieldId = fieldId;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public boolean equals(Object object) {
        if (this == object) return true;
        if (object == null || getClass() != object.getClass()) return false;
        if (!super.equals(object)) return false;
        JvmStringConstant that = (JvmStringConstant) object;
        return Objects.equals(fieldId, that.fieldId) &&
               Objects.equals(value, that.value);
    }

    public int hashCode() {

        return Objects.hash(super.hashCode(), fieldId, value);
    }

    public void fromMap(Map<String, Object> map){
        super.fromMap(map);
        this.fieldId = (String) map.get("fieldId");
        this.value   = (String) map.get("value");
    }

}
