package org.clyze.persistent.model;

import java.util.Map;
import java.util.Objects;

/**
 * This class represents a string constant; i.e. a pair of a static final String
 * field and the string literal initializing it.
 *
 * Why we need this?
 * Javac chooses to inline some cases of static final fields. Such fields do not
 * appear in the bytecode and therefore are not analyzed. What this class does
 * is to provide a "possible value" for such fields.
 */
public class StringConstant extends Symbol {

    /** The doopId of the static final field that this string literal initializes. */
    private String fieldDoopId;

    /** The string literal value.
     *
     *  This value may differ from the corresponding source code, since it is
     *  intentionally retrieved after the compiler has applied any possible
     *  concatenations; e.g. for the string literal in the rhs of:
     *      static final String str = "abc" + "def";
     *  javac will give us "abcdef", which we store in "value".
     *
     *  Note that the reported position corresponds to the source code and not
     *  the concatenated string generated by the compiler.
     */
    private String value;

    public StringConstant() {}

    public StringConstant(String id) {
        this.id = id;
    }
    
    public StringConstant(Position position, 
                          String sourceFileName, 
                          String fieldDoopId, 
                          String value) {
        super(position, sourceFileName);
        this.fieldDoopId = fieldDoopId;
        this.value = value;
    }

    protected void saveTo(Map<String, Object> map) {
        super.saveTo(map);
        map.put("fieldDoopId", this.fieldDoopId);
        map.put("value", this.value);
    }

    public String getFieldDoopId() {
        return fieldDoopId;
    }

    public void setFieldDoopId(String fieldDoopId) {
        this.fieldDoopId = fieldDoopId;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public boolean equals(Object object) {
        if (this == object) return true;
        if (object == null || getClass() != object.getClass()) return false;
        if (!super.equals(object)) return false;
        StringConstant that = (StringConstant) object;
        return Objects.equals(fieldDoopId, that.fieldDoopId) &&
               Objects.equals(value, that.value);
    }

    public int hashCode() {

        return Objects.hash(super.hashCode(), fieldDoopId, value);
    }

    public void fromMap(Map<String, Object> map){
        super.fromMap(map);
        this.fieldDoopId = (String) map.get("fieldDoopId");
        this.value       = (String) map.get("value");
    }

}
